/**
 * Batch Export Service
 * Export multiple plans at once
 */

import JSZip from "jszip";
import { PDFExportService } from "./export.service";
import { ComprehensiveReportService } from "./comprehensive-export.service";

interface BatchExportOptions {
    planIds: string[];
    includeAnalytics: boolean;
    format: "simple" | "comprehensive";
}

interface PlanExportData {
    id: string;
    name: string;
    pdfBlob: Blob;
}

export class BatchExportService {
    /**
     * Export multiple plans as ZIP
     */
    static async exportPlansAsZip(
        plans: any[],
        options: BatchExportOptions
    ): Promise<Blob> {
        const zip = new JSZip();

        // Create summary document
        const summary = this.generateSummaryDocument(plans);
        zip.file("00-SUMMARY.txt", summary);

        // Add each plan
        for (let i = 0; i < plans.length; i++) {
            const plan = plans[i];
            const planFolder = zip.folder(`${i + 1}-${this.sanitizeFilename(plan.name)}`);

            if (!planFolder) continue;

            // Generate PDF
            let pdfBlob: Blob;
            if (options.format === "comprehensive" && options.includeAnalytics) {
                const doc = ComprehensiveReportService.generateComprehensiveReport(plan);
                pdfBlob = doc.output("blob");
            } else {
                const doc = PDFExportService.generatePDF(plan);
                pdfBlob = doc.output("blob");
            }

            // Add PDF to folder
            planFolder.file(`${this.sanitizeFilename(plan.name)}.pdf`, pdfBlob);

            // Add metadata JSON
            const metadata = this.generateMetadata(plan);
            planFolder.file("metadata.json", JSON.stringify(metadata, null, 2));

            // Add DIKSHA metadata if applicable
            if (plan.status === "PUBLISHED") {
                const dikshaMetadata = this.generateDIKSHAMetadata(plan);
                planFolder.file("diksha-metadata.json", JSON.stringify(dikshaMetadata, null, 2));
            }
        }

        // Generate ZIP
        return await zip.generateAsync({ type: "blob" });
    }

    /**
     * Generate summary document
     */
    private static generateSummaryDocument(plans: any[]): string {
        let summary = "TRAINING PLANS EXPORT SUMMARY\n";
        summary += "=".repeat(50) + "\n\n";
        summary += `Export Date: ${new Date().toLocaleString("en-IN")}\n`;
        summary += `Total Plans: ${plans.length}\n\n`;
        summary += "=".repeat(50) + "\n\n";

        plans.forEach((plan, index) => {
            summary += `${index + 1}. ${plan.name}\n`;
            summary += `   Cohort: ${plan.cohort.name}\n`;
            summary += `   Sessions: ${plan.sessionCount}\n`;
            summary += `   Duration: ${plan.totalDurationMinutes} minutes\n`;
            summary += `   Status: ${plan.status}\n`;

            if (plan.analytics && plan.analytics.totalFeedback > 0) {
                summary += `   Avg Relevance: ${plan.analytics.avgRelevance.toFixed(1)}/5\n`;
                summary += `   Avg Confidence: ${plan.analytics.avgConfidence.toFixed(1)}/5\n`;
            }

            summary += "\n";
        });

        summary += "=".repeat(50) + "\n";
        summary += "Generated by DIET Training OS\n";

        return summary;
    }

    /**
     * Generate plan metadata
     */
    private static generateMetadata(plan: any): any {
        return {
            id: plan.id,
            name: plan.name,
            description: plan.description,
            cohort: {
                name: plan.cohort.name,
                primaryIssues: plan.cohort.primaryIssues,
                language: plan.cohort.language,
                infrastructureLevel: plan.cohort.infrastructureLevel,
                gradeBand: plan.cohort.gradeBand,
            },
            sessions: plan.sessions.map((s: any) => ({
                sessionNumber: s.sessionNumber,
                title: s.title,
                module: s.module.title,
                theme: s.module.theme,
                duration: s.durationMinutes,
            })),
            analytics: plan.analytics || null,
            createdAt: plan.createdAt,
            publishedAt: plan.publishedAt || null,
            exportedAt: new Date().toISOString(),
        };
    }

    /**
     * Generate DIKSHA-compatible metadata
     */
    private static generateDIKSHAMetadata(plan: any): any {
        const gradeBandMapping: Record<string, string[]> = {
            primary_1_3: ["Grade 1", "Grade 2", "Grade 3"],
            primary_4_5: ["Grade 4", "Grade 5"],
            secondary_6_8: ["Grade 6", "Grade 7", "Grade 8"],
            secondary_9_10: ["Grade 9", "Grade 10"],
        };

        const gradeLevel = plan.cohort.gradeBand
            ? gradeBandMapping[plan.cohort.gradeBand] || []
            : [];

        const topics = Array.from(
            new Set(plan.sessions.map((s: any) => s.module.theme))
        );

        const keywords = Array.from(
            new Set([
                ...plan.cohort.primaryIssues,
                ...plan.sessions.flatMap((s: any) => s.module.competencyTags),
            ])
        );

        return {
            identifier: `diet_plan_${plan.id}`,
            name: plan.name,
            description: plan.description,
            contentType: "Course",
            mimeType: "application/pdf",
            language: [plan.cohort.language],
            medium: [plan.cohort.language],
            gradeLevel,
            subject: ["Teacher Training"],
            topic: topics,
            keywords,
            audience: ["Teacher", "Teacher Educator"],
            attributions: ["DIET", "SCERT"],
            copyright: "SCERT",
            license: "CC BY 4.0",
            status: "Live",
            createdOn: plan.createdAt,
            lastUpdatedOn: plan.publishedAt || plan.createdAt,
            duration: plan.totalDurationMinutes,
            sessionCount: plan.sessionCount,
        };
    }

    /**
     * Sanitize filename
     */
    private static sanitizeFilename(filename: string): string {
        return filename
            .replace(/[^a-z0-9]/gi, "-")
            .replace(/-+/g, "-")
            .toLowerCase()
            .substring(0, 50);
    }

    /**
     * Get estimated ZIP size
     */
    static getEstimatedZipSize(planCount: number, avgSessionCount: number): string {
        const avgPlanSize = 100; // KB
        const totalKB = planCount * avgPlanSize + 50; // 50 KB overhead

        if (totalKB < 1024) {
            return `${totalKB} KB`;
        } else {
            return `${(totalKB / 1024).toFixed(1)} MB`;
        }
    }
}
